#include "common.h"
#include "sys_eny.h"

using namespace std;
//二维数组用来指定各个handler的起始地址和handler的大小。
char ele_h000[] = {/* 0x00, 0x00, 0xd7, 0xe5, 0x00, 0x01, 0x96, 0xe7,0x01, 0x00, 0x2d, 0xe9*/0x01,0x00 ,0xBD ,0xE8 ,0x06 ,0x10 ,0xA0 ,0xE1  ,0x04 ,0x11 ,0x81 ,0xE0 ,0x01 ,0x40 ,0x84 ,0xE2 ,0x00 ,0x00 ,0x81 ,0xE5, 0x00, 0x00, 0xA0, 0xE1 };
char ele_h001[] = { 0x04,0x40,0x44 ,0xE0,0x00, 0x00, 0xA0, 0xE1 };
char ele_h002[] = { 0x00,0x00,0xD7 ,0xE5 ,0x00 ,0x41 ,0x96,0xE7  ,0x10 ,0x00 ,0x2D ,0xE9 ,0x01 ,0x70 ,0x87 ,0xE2, 0x00, 0x00, 0xA0, 0xE1 };
char ele_h003[] = { 0x01,0x00,0xBD ,0xE8 ,0x00 ,0x10 ,0x9D ,0xE5  ,0x00 ,0x10 ,0x81 ,0xE0 ,0x02 ,0x00 ,0x2D ,0xE9, 0x00, 0x00, 0xA0, 0xE1 };
char ele_h004[] = { 0x00,0x00 ,0xD7 ,0xE5 ,0x00,0x41,0x86,0xE0 ,0x08,0x00 ,0xBD ,0xE8 ,0x00 ,0x30 ,0x84 ,0xE5,0x01,0x70,0x87,0xe2, 0x00, 0x00, 0xA0, 0xE1 };
char ele_h075[] = { 0x0d, 0x30, 0xa0, 0xe1, 0x00, 0x00, 0xA0, 0xE1 };
char ele_h007[] = { 0x08, 0x00, 0x2d, 0xe9 , 0x00, 0x00, 0xA0, 0xE1 };
char ele_h005[] = { 0x01, 0x00, 0xbd, 0xe8, 0x00, 0xd0,0x8d, 0xe0, 0x00, 0xd0, 0x8d, 0xe5 , 0x00, 0x00, 0xA0, 0xE1 };
char ele_h074[] = { 0x01, 0x00, 0xbd, 0xe8, 0x00, 0x00, 0x8d, 0xe5, 0x00, 0x00, 0xA0, 0xE1 };
char ele_h00A[] = { 0x00, 0xD0, 0x83, 0xE5, 0x00, 0x00, 0xA0, 0xE1 };
//char ele_h00A[] = { 0x04,0x60 ,0x86 ,0xE2 ,0x00 ,0xE0 ,0x96 ,0xE5  ,0x04 ,0x60 ,0x86 ,0xE2 ,0x00 ,0x70 ,0x96 ,0xE5
//,0x04 ,0x60 ,0x86 ,0xE2 ,0x00 ,0x50 ,0x96 ,0xE5  ,0x04 ,0x60 ,0x86 ,0xE2 ,0x00 ,0x40 ,0x96 ,0xE5
//,0x04 ,0x60 ,0x86 ,0xE2 ,0x00 ,0x30,0x96 ,0xE5  ,0x04 ,0x60 ,0x86 ,0xE2 ,0x00 ,0x20 ,0x96 ,0xE5
//,0x04 ,0x60 ,0x86 ,0xE2 ,0x00 ,0x10 ,0x96 ,0xE5  ,0x04 ,0x60 ,0x86 ,0xE2 ,0x00 ,0x00 ,0x96 ,0xE5
//,0x04 ,0x60 ,0x86 ,0xE2 ,0x00 ,0x60 ,0x96 ,0xE5  ,0x00 ,0xF0 ,0x20 ,0xE3 ,0x00, 0x00, 0xA0, 0xE1 };
//char ele_h012[] = { 0x00, 0x10,0x93, 0xe5, 0x02, 0x00, 0xbd, 0xe8 , 0x00, 0x00, 0xA0, 0xE1 };
//ele_h012用于退出虚拟机
char ele_h012[] = { 0x00,0x00 ,0x96 ,0xE5 ,0x04 ,0x60 ,0x86 ,0xE2  ,0x00 ,0x10 ,0x96 ,0xE5 ,0x04 ,0x60 ,0x86 ,0xE2,
0x00 ,0x20 ,0x96 ,0xE5 ,0x04 ,0x60 ,0x86 ,0xE2  ,0x00 ,0x30 ,0x96 ,0xE5 ,0x04 ,0x60 ,0x86 ,0xE2,
0x00 ,0x40 ,0x96 ,0xE5 ,0x04 ,0x60 ,0x86 ,0xE2  ,0x00 ,0x50 ,0x96 ,0xE5 ,
0x08,0x60 ,0x86 ,0xE2 ,0x00 ,0x70 ,0x96 ,0xE5  ,0x04 ,0x60 ,0x86 ,0xE2 ,0x00 ,0xE0 ,0x96 ,0xE5,0x08 ,0x60 ,0x46 ,0xE2 ,0x00 ,0x60 ,0x96 ,0xE5,
0x00, 0x00, 0xA0, 0xE1 };



BYTE hex_addr[4] = { 0 };
BYTE* switchEndian(DWORD _rva)
{
	hex_addr[0] = (BYTE)(0xff & _rva);
	hex_addr[1] = (BYTE)((0xff00 & _rva) >> 8);
	hex_addr[2] = (BYTE)((0xff0000 & _rva) >> 16);
	hex_addr[3] = (BYTE)((0xff000000 & _rva) >> 24);
	return hex_addr;
}

void Common::handler_init()
{
	
	for (int i = 0; i < sizeof(ele_h000); i++)
	{
		h000.push_back(ele_h000[i]);
	}

	handlers[0].addr = &h000[0];
	handlers[0].size = h000.size();
	for (int i = 0; i < sizeof(ele_h001); i++)
	{
		h001.push_back(ele_h001[i]);
	}
	handlers[1].addr = &h001[0];
	handlers[1].size = h001.size();
	for (int i = 0; i < sizeof(ele_h002); i++)
	{
		h002.push_back(ele_h002[i]);
	}
	handlers[2].addr = &h002[0];
	handlers[2].size = h002.size();
	for (int i = 0; i < sizeof(ele_h003); i++)
	{
		h003.push_back(ele_h003[i]);
	}
	handlers[3].addr = &h003[0];
	handlers[3].size = h003.size();
	for (int i = 0; i < sizeof(ele_h004); i++)
	{
		h004.push_back(ele_h004[i]);
	}
	handlers[4].addr = &h004[0];
	handlers[4].size = h004.size();
	for (int i = 0; i < sizeof(ele_h075); i++)
	{
		h075.push_back(ele_h075[i]);
	}
	handlers[5].addr = &h075[0];
	handlers[5].size = h075.size();
	for (int i = 0; i < sizeof(ele_h007); i++)
	{
		h007.push_back(ele_h007[i]);
	}
	handlers[6].addr = &h007[0];
	handlers[6].size = h007.size();
	for (int i = 0; i < sizeof(ele_h005); i++)
	{
		h005.push_back(ele_h005[i]);
	}
	handlers[7].addr = &h005[0];
	handlers[7].size = h005.size();
	for (int i = 0; i < sizeof(ele_h074); i++)
	{
		h074.push_back(ele_h074[i]);
	}
	handlers[8].addr = &h074[0];
	handlers[8].size = h074.size();
	for (int i = 0; i < sizeof(ele_h00A); i++)
	{
		h00A.push_back(ele_h00A[i]);
	}
	handlers[9].addr = &h00A[0];
	handlers[9].size = h00A.size();
	for (int i = 0; i < sizeof(ele_h012); i++)
	{
		h012.push_back(ele_h012[i]);
	}
	handlers[10].addr = &h012[0];
	handlers[10].size = h012.size();

	//for (int i = 0; i < sizeof(ele_h013); i++)
	//{
	//	h013.push_back(ele_h013[i]);
	//}
	//handlers[11].addr = &h013[0];
	//handlers[11].size = h013.size();


}

DWORD string_to_hex(const char * str)
{
	int i = 0;
	char* index = "0123456789abcdef";
	char* temp = strdup(str); //copy
	char*lower = strlwr(temp);//转底
	char* find = NULL;
	DWORD dword = 0;
	if (strstr(lower, "short "))
	{
		strcpy(lower, lower + 6);
	}
	else if (strstr(lower, "far "))
	{
		strcpy(lower, lower + 4);
	}
	else { ; }
	while (i < strlen(lower))
	{
		find = strchr(index, lower[i]);//返回首次出现lower[i]的位置

		dword = dword ^ (((DWORD)(find - index)) << ((strlen(lower) - 1 - i) * 4));

		i++;

	}
	return dword;

	return 0;
}
